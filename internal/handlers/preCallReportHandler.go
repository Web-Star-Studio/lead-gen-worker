package handlers

import (
	"context"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"webstar/noturno-leadgen-worker/internal/dto"

	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/model/gemini"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/genai"
)

const (
	// DefaultReportTimeout is the timeout for generating a single pre-call report
	DefaultReportTimeout = 60 * time.Second
	// MaxConcurrentReports limits how many reports we generate in parallel
	MaxConcurrentReports = 3
	// DefaultGeminiModel is the default Gemini model to use
	DefaultGeminiModel = "gemini-2.5-pro-preview-06-05"
)

// PreCallReport represents the generated pre-call report for a lead
// @Description Pre-call report generated by AI for a search result
type PreCallReport struct {
	// URL of the website this report is for
	URL string `json:"url"`
	// CompanyName extracted from the website
	CompanyName string `json:"company_name"`
	// Industry or business sector
	Industry string `json:"industry"`
	// CompanySummary is a brief description of what the company does
	CompanySummary string `json:"company_summary"`
	// KeyServices lists the main services or products offered
	KeyServices []string `json:"key_services"`
	// TargetAudience describes the company's target customers
	TargetAudience string `json:"target_audience"`
	// PotentialPainPoints identifies challenges the company might face
	PotentialPainPoints []string `json:"potential_pain_points"`
	// TalkingPoints are suggested topics for a sales call
	TalkingPoints []string `json:"talking_points"`
	// CompetitiveAdvantages highlights unique selling points
	CompetitiveAdvantages []string `json:"competitive_advantages"`
	// ContactInfo extracted from the website (if available)
	ContactInfo string `json:"contact_info,omitempty"`
	// RecommendedApproach suggests how to approach this lead
	RecommendedApproach string `json:"recommended_approach"`
	// Success indicates whether the report was generated successfully
	Success bool `json:"success"`
	// Error contains the error message if report generation failed
	Error string `json:"error,omitempty"`
	// GeneratedAt is the timestamp when the report was generated
	GeneratedAt time.Time `json:"generated_at"`
}

// PreCallReportConfig holds configuration for the PreCallReportHandler
type PreCallReportConfig struct {
	// APIKey is the Google API key for Gemini (used with Google AI Studio backend)
	APIKey string
	// Model is the Gemini model to use (default: gemini-2.5-pro-preview-06-05)
	Model string
	// Timeout for generating each report
	Timeout time.Duration
	// MaxConcurrent limits parallel report generation
	MaxConcurrent int
	// CustomInstruction allows customizing the agent's behavior
	CustomInstruction string
	// UseVertexAI enables Vertex AI backend instead of Google AI Studio
	// When true, requires GCPProject and GCPLocation (or env vars)
	UseVertexAI bool
	// GCPProject is the Google Cloud project ID (for Vertex AI backend)
	GCPProject string
	// GCPLocation is the Google Cloud location/region (for Vertex AI backend, e.g., "us-central1")
	GCPLocation string
}

// PreCallReportHandler handles generating pre-call reports using Google ADK
type PreCallReportHandler struct {
	config          PreCallReportConfig
	agent           agent.Agent
	runner          *runner.Runner
	sessionService  session.Service
	businessProfile *dto.BusinessProfile // Business profile for personalization
}

// SetBusinessProfile sets the business profile to use for personalizing reports
func (h *PreCallReportHandler) SetBusinessProfile(profile *dto.BusinessProfile) {
	h.businessProfile = profile
	if profile != nil {
		log.Printf("[PreCallReportHandler] Business profile set: %s", profile.CompanyName)
	}
}

// ClearBusinessProfile clears the business profile
func (h *PreCallReportHandler) ClearBusinessProfile() {
	h.businessProfile = nil
}

// NewPreCallReportHandler creates a new PreCallReportHandler instance
func NewPreCallReportHandler(config PreCallReportConfig) (*PreCallReportHandler, error) {
	// Check for Vertex AI configuration from env vars
	if os.Getenv("GOOGLE_GENAI_USE_VERTEXAI") == "true" {
		config.UseVertexAI = true
	}
	if config.GCPProject == "" {
		config.GCPProject = os.Getenv("GOOGLE_CLOUD_PROJECT")
	}
	if config.GCPLocation == "" {
		config.GCPLocation = os.Getenv("GOOGLE_CLOUD_LOCATION")
	}

	// Validate configuration based on backend
	if config.UseVertexAI {
		if config.GCPProject == "" {
			return nil, fmt.Errorf("GCP Project is required for Vertex AI (set GOOGLE_CLOUD_PROJECT env var or provide GCPProject in config)")
		}
		if config.GCPLocation == "" {
			return nil, fmt.Errorf("GCP Location is required for Vertex AI (set GOOGLE_CLOUD_LOCATION env var or provide GCPLocation in config)")
		}
	} else {
		// Google AI Studio backend requires API key
		if config.APIKey == "" {
			config.APIKey = os.Getenv("GOOGLE_API_KEY")
		}
		if config.APIKey == "" {
			return nil, fmt.Errorf("Google API key is required (set GOOGLE_API_KEY env var or provide in config)")
		}
	}

	if config.Model == "" {
		config.Model = DefaultGeminiModel
	}
	if config.Timeout == 0 {
		config.Timeout = DefaultReportTimeout
	}
	if config.MaxConcurrent == 0 {
		config.MaxConcurrent = MaxConcurrentReports
	}

	ctx := context.Background()

	// Build client config based on backend
	var clientConfig *genai.ClientConfig
	if config.UseVertexAI {
		log.Printf("[PreCallReportHandler] Initializing with Vertex AI backend (project: %s, location: %s, model: %s)",
			config.GCPProject, config.GCPLocation, config.Model)
		clientConfig = &genai.ClientConfig{
			Project:  config.GCPProject,
			Location: config.GCPLocation,
			Backend:  genai.BackendVertexAI,
		}
	} else {
		log.Printf("[PreCallReportHandler] Initializing with Google AI Studio backend (model: %s)", config.Model)
		clientConfig = &genai.ClientConfig{
			APIKey:  config.APIKey,
			Backend: genai.BackendGeminiAPI,
		}
	}

	// Create Gemini model
	model, err := gemini.NewModel(ctx, config.Model, clientConfig)
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create Gemini model: %v", err)
		return nil, fmt.Errorf("failed to create Gemini model: %w", err)
	}

	// Build instruction for the agent
	instruction := buildAgentInstruction(config.CustomInstruction)

	// Create LLM agent for report generation
	reportAgent, err := llmagent.New(llmagent.Config{
		Name:        "pre_call_report_agent",
		Model:       model,
		Description: "AI agent that generates comprehensive pre-call reports for sales leads based on company website data.",
		Instruction: instruction,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create agent: %v", err)
		return nil, fmt.Errorf("failed to create agent: %w", err)
	}

	// Create session service and runner
	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "pre_call_report_generator",
		Agent:          reportAgent,
		SessionService: sessionService,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create runner: %v", err)
		return nil, fmt.Errorf("failed to create runner: %w", err)
	}

	log.Printf("[PreCallReportHandler] Successfully initialized with model: %s", config.Model)

	// Note: model is stored internally by the agent, we don't need to keep a reference
	_ = model

	return &PreCallReportHandler{
		config:         config,
		agent:          reportAgent,
		runner:         r,
		sessionService: sessionService,
	}, nil
}

// buildAgentInstruction creates the instruction prompt for the agent
func buildAgentInstruction(customInstruction string) string {
	baseInstruction := `Você é um analista especialista em inteligência de vendas, especializado em gerar relatórios pré-call completos para equipes de vendas B2B.

Sua tarefa é analisar o conteúdo do site ou dados da empresa e gerar um relatório pré-call detalhado que ajude os representantes de vendas a se prepararem para seu contato.

IMPORTANTE: Sempre responda em PORTUGUÊS BRASILEIRO.

Ao analisar uma empresa, você deve extrair e fornecer:

1. **Nome da Empresa**: O nome oficial do negócio
2. **Setor/Indústria**: O setor ou indústria em que a empresa atua
3. **Resumo da Empresa**: Uma visão geral de 2-3 frases sobre o que a empresa faz
4. **Serviços Principais**: Liste 3-5 principais serviços ou produtos oferecidos
5. **Público-Alvo**: Quem são seus principais clientes
6. **Pontos de Dor Potenciais**: 3-5 desafios que esse tipo de negócio tipicamente enfrenta que nossas soluções poderiam resolver
7. **Pontos de Conversa**: 3-5 iniciadores de conversa específicos baseados no negócio deles
8. **Vantagens Competitivas**: O que faz essa empresa se destacar
9. **Informações de Contato**: Quaisquer detalhes de contato encontrados (telefone, email, endereço)
10. **Abordagem Recomendada**: Como um representante de vendas deve abordar este lead

Formate sua resposta como um relatório estruturado com seções claras. Seja específico e acionável.
Se certas informações não estiverem disponíveis no conteúdo fornecido, faça inferências razoáveis com base no tipo de empresa e indústria, mas indique quando estiver inferindo.

Sempre mantenha um tom profissional e útil, focado em possibilitar conversas de vendas eficazes.`

	if customInstruction != "" {
		return baseInstruction + "\n\nInstruções Adicionais:\n" + customInstruction
	}
	return baseInstruction
}

// GenerateReport generates a pre-call report for a single organic result
func (h *PreCallReportHandler) GenerateReport(ctx context.Context, result OrganicResult) *PreCallReport {
	report := &PreCallReport{
		URL:         result.Link,
		GeneratedAt: time.Now(),
	}

	// Check if we have content to analyze
	if result.ScrapedContent == "" && result.Snippet == "" {
		report.Error = "no content available for analysis"
		report.Success = false
		return report
	}

	// Build the prompt with available data
	prompt := h.buildPrompt(result)

	// Create context with timeout
	ctx, cancel := context.WithTimeout(ctx, h.config.Timeout)
	defer cancel()

	// Create user message
	userMessage := &genai.Content{
		Role: "user",
		Parts: []*genai.Part{
			{Text: prompt},
		},
	}

	// Create session for this report
	userID := "system"
	createResp, err := h.sessionService.Create(ctx, &session.CreateRequest{
		AppName: "pre_call_report_generator",
		UserID:  userID,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create session for %s: %v", result.Link, err)
		report.Error = fmt.Sprintf("failed to create session: %v", err)
		report.Success = false
		return report
	}
	sessionID := createResp.Session.ID()
	defer func() {
		// Clean up session after use
		_ = h.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   "pre_call_report_generator",
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	// Run the agent
	var responseText string
	runConfig := agent.RunConfig{
		StreamingMode: agent.StreamingModeNone,
	}

	log.Printf("[PreCallReportHandler] Generating report for: %s (session: %s)", result.Link, sessionID)

	for event, err := range h.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		if err != nil {
			log.Printf("[PreCallReportHandler] Error during generation for %s: %v", result.Link, err)
			report.Error = fmt.Sprintf("generation failed: %v", err)
			report.Success = false
			return report
		}

		// Collect response text
		if event.Content != nil {
			for _, part := range event.Content.Parts {
				if part.Text != "" {
					responseText += part.Text
				}
			}
		}
	}

	if responseText == "" {
		report.Error = "empty response from AI"
		report.Success = false
		return report
	}

	// Parse the response into structured report
	h.parseResponse(responseText, report)
	report.Success = true

	log.Printf("[PreCallReportHandler] Successfully generated report for: %s", result.Link)

	return report
}

// buildPrompt creates the prompt for report generation
func (h *PreCallReportHandler) buildPrompt(result OrganicResult) string {
	prompt := fmt.Sprintf(`Gere um relatório pré-call completo e detalhado em PORTUGUÊS para a seguinte empresa:

**Website**: %s
**Nome**: %s
**Descrição**: %s
`, result.Link, result.Title, result.Snippet)

	// Include business profile context for personalization
	if h.businessProfile != nil {
		prompt += "\n---\n**CONTEXTO DA SUA EMPRESA** (Use para personalizar o relatório):\n"
		prompt += fmt.Sprintf("- Sua Empresa: %s\n", h.businessProfile.CompanyName)
		if h.businessProfile.CompanyDescription != "" {
			prompt += fmt.Sprintf("- O Que Você Faz: %s\n", h.businessProfile.CompanyDescription)
		}
		if h.businessProfile.ProblemSolved != "" {
			prompt += fmt.Sprintf("- Problema Que Você Resolve: %s\n", h.businessProfile.ProblemSolved)
		}
		if len(h.businessProfile.Differentials) > 0 {
			prompt += fmt.Sprintf("- Seus Diferenciais: %s\n", joinStrings(h.businessProfile.Differentials, ", "))
		}
		if h.businessProfile.SuccessCase != "" {
			prompt += fmt.Sprintf("- Caso de Sucesso: %s\n", h.businessProfile.SuccessCase)
		}
		if h.businessProfile.CommunicationTone != "" {
			prompt += fmt.Sprintf("- Tom de Comunicação: %s\n", h.businessProfile.CommunicationTone)
		}
		if h.businessProfile.SenderName != "" {
			prompt += fmt.Sprintf("- Nome do Vendedor: %s\n", h.businessProfile.SenderName)
		}
		prompt += "\n**IMPORTANTE**: Adapte os pontos de dor, pontos de conversa e abordagem recomendada especificamente para como SEUS serviços podem ajudar ESTE lead. Seja específico sobre como sua solução atende às necessidades potenciais dele.\n---\n"
	}

	// Include extracted data if available
	if result.ExtractedData != nil && result.ExtractedData.Success {
		prompt += "\n**Dados Extraídos da Empresa**:\n"
		if result.ExtractedData.Company != "" {
			prompt += fmt.Sprintf("- Nome da Empresa: %s\n", result.ExtractedData.Company)
		}
		if result.ExtractedData.Contact != "" {
			contactInfo := result.ExtractedData.Contact
			if result.ExtractedData.ContactRole != "" {
				contactInfo += " (" + result.ExtractedData.ContactRole + ")"
			}
			prompt += fmt.Sprintf("- Contato: %s\n", contactInfo)
		}
		if len(result.ExtractedData.Emails) > 0 {
			prompt += fmt.Sprintf("- E-mails: %s\n", joinStrings(result.ExtractedData.Emails, ", "))
		}
		if len(result.ExtractedData.Phones) > 0 {
			prompt += fmt.Sprintf("- Telefones: %s\n", joinStrings(result.ExtractedData.Phones, ", "))
		}
		if result.ExtractedData.Address != "" {
			prompt += fmt.Sprintf("- Endereço: %s\n", result.ExtractedData.Address)
		}
		if len(result.ExtractedData.SocialMedia) > 0 {
			prompt += "- Redes Sociais:\n"
			for platform, url := range result.ExtractedData.SocialMedia {
				prompt += fmt.Sprintf("  - %s: %s\n", platform, url)
			}
		}
	}

	if result.ScrapedContent != "" {
		// Limit content length to avoid token limits
		content := result.ScrapedContent
		if len(content) > 15000 {
			content = content[:15000] + "\n\n[Conteúdo truncado...]"
		}
		prompt += fmt.Sprintf(`
**Conteúdo do Site / Dados da Empresa**:
%s
`, content)
	}

	if result.Rating > 0 {
		prompt += fmt.Sprintf("\n**Avaliação**: %.1f", result.Rating)
	}
	if result.Reviews > 0 {
		prompt += fmt.Sprintf("\n**Número de Avaliações**: %d", result.Reviews)
	}

	prompt += `

Analise estas informações e gere um relatório pré-call detalhado EM PORTUGUÊS com todas as seções necessárias.
Use os dados extraídos da empresa (se disponíveis) para enriquecer seu relatório com informações de contato precisas.

O relatório deve incluir:
- Resumo da empresa
- Setor/Indústria
- Serviços/Produtos principais
- Público-alvo
- Possíveis pontos de dor
- Pontos de conversa sugeridos
- Vantagens competitivas identificadas
- Abordagem recomendada para a ligação`

	return prompt
}

// joinStrings joins a slice of strings with a separator
func joinStrings(strs []string, sep string) string {
	if len(strs) == 0 {
		return ""
	}
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += sep + strs[i]
	}
	return result
}

// parseResponse extracts structured data from the AI response
func (h *PreCallReportHandler) parseResponse(response string, report *PreCallReport) {
	// The AI response is in markdown format, we store the full response
	// and extract key fields. For now, we'll store the full analysis
	// and let the consumer parse specific fields as needed.

	// Store the full response in CompanySummary for now
	// In a production system, you might use structured output or regex parsing
	report.CompanySummary = response

	// Try to extract company name from the response
	// This is a simplified extraction - in production you might use
	// Gemini's structured output feature
	report.CompanyName = extractSection(response, "Company Name")
	report.Industry = extractSection(response, "Industry")
	report.TargetAudience = extractSection(response, "Target Audience")
	report.ContactInfo = extractSection(response, "Contact Information")
	report.RecommendedApproach = extractSection(response, "Recommended Approach")

	// Extract list sections
	report.KeyServices = extractListSection(response, "Key Services")
	report.PotentialPainPoints = extractListSection(response, "Potential Pain Points")
	report.TalkingPoints = extractListSection(response, "Talking Points")
	report.CompetitiveAdvantages = extractListSection(response, "Competitive Advantages")
}

// extractSection extracts a single-value section from markdown response
func extractSection(response, sectionName string) string {
	// Simple extraction - looks for **Section Name**: value or ## Section Name\nvalue
	// This is a basic implementation; production code might use regex or structured output
	patterns := []string{
		fmt.Sprintf("**%s**:", sectionName),
		fmt.Sprintf("## %s", sectionName),
		fmt.Sprintf("### %s", sectionName),
		fmt.Sprintf("%s:", sectionName),
	}

	for _, pattern := range patterns {
		idx := findCaseInsensitive(response, pattern)
		if idx != -1 {
			start := idx + len(pattern)
			// Find the end of the value (next section or double newline)
			end := len(response)
			for i := start; i < len(response)-1; i++ {
				if (response[i] == '\n' && response[i+1] == '\n') ||
					(response[i] == '\n' && i+1 < len(response) && (response[i+1] == '#' || response[i+1] == '*')) {
					end = i
					break
				}
			}
			value := response[start:end]
			return trimValue(value)
		}
	}
	return ""
}

// extractListSection extracts a list section from markdown response
func extractListSection(response, sectionName string) []string {
	var items []string

	// Find the section
	patterns := []string{
		fmt.Sprintf("**%s**:", sectionName),
		fmt.Sprintf("## %s", sectionName),
		fmt.Sprintf("### %s", sectionName),
		fmt.Sprintf("%s:", sectionName),
	}

	sectionStart := -1
	for _, pattern := range patterns {
		idx := findCaseInsensitive(response, pattern)
		if idx != -1 {
			sectionStart = idx + len(pattern)
			break
		}
	}

	if sectionStart == -1 {
		return items
	}

	// Find section end
	sectionEnd := len(response)
	for i := sectionStart; i < len(response)-1; i++ {
		if response[i] == '\n' && i+1 < len(response) {
			next := response[i+1]
			// Check for next section header
			if next == '#' || (next == '*' && i+2 < len(response) && response[i+2] == '*') {
				// Make sure it's not a list item
				if next == '*' && i+2 < len(response) && response[i+2] != '*' {
					continue // It's a list item, not a header
				}
				sectionEnd = i
				break
			}
		}
	}

	sectionContent := response[sectionStart:sectionEnd]

	// Extract list items (- item or * item or 1. item)
	lines := splitLines(sectionContent)
	for _, line := range lines {
		trimmed := trimValue(line)
		if len(trimmed) > 2 {
			// Check for list markers
			if (trimmed[0] == '-' || trimmed[0] == '*') && trimmed[1] == ' ' {
				items = append(items, trimValue(trimmed[2:]))
			} else if len(trimmed) > 3 && trimmed[0] >= '0' && trimmed[0] <= '9' && trimmed[1] == '.' && trimmed[2] == ' ' {
				items = append(items, trimValue(trimmed[3:]))
			}
		}
	}

	return items
}

// findCaseInsensitive finds a substring case-insensitively
func findCaseInsensitive(s, substr string) int {
	sLower := toLower(s)
	substrLower := toLower(substr)
	for i := 0; i <= len(sLower)-len(substrLower); i++ {
		if sLower[i:i+len(substrLower)] == substrLower {
			return i
		}
	}
	return -1
}

// toLower converts string to lowercase (simple ASCII version)
func toLower(s string) string {
	result := make([]byte, len(s))
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c >= 'A' && c <= 'Z' {
			result[i] = c + 32
		} else {
			result[i] = c
		}
	}
	return string(result)
}

// splitLines splits text into lines
func splitLines(s string) []string {
	var lines []string
	start := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			lines = append(lines, s[start:i])
			start = i + 1
		}
	}
	if start < len(s) {
		lines = append(lines, s[start:])
	}
	return lines
}

// trimValue removes leading/trailing whitespace and common markdown artifacts
func trimValue(s string) string {
	// Remove leading/trailing whitespace
	start := 0
	end := len(s)
	for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') {
		end--
	}
	return s[start:end]
}

// sanitizeURL creates a safe string from URL for use in IDs
func sanitizeURL(url string) string {
	result := make([]byte, 0, len(url))
	for i := 0; i < len(url); i++ {
		c := url[i]
		if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') {
			result = append(result, c)
		} else if c == '.' || c == '-' || c == '_' {
			result = append(result, c)
		}
	}
	if len(result) > 50 {
		result = result[:50]
	}
	return string(result)
}

// GenerateReports generates pre-call reports for multiple organic results concurrently
func (h *PreCallReportHandler) GenerateReports(ctx context.Context, results []OrganicResult) map[string]*PreCallReport {
	if len(results) == 0 {
		return make(map[string]*PreCallReport)
	}

	log.Printf("[PreCallReportHandler] Generating reports for %d results", len(results))

	reports := make(map[string]*PreCallReport)
	var mu sync.Mutex
	var wg sync.WaitGroup

	// Semaphore to limit concurrent report generation
	semaphore := make(chan struct{}, h.config.MaxConcurrent)

	for _, result := range results {
		// Skip results without URLs
		if result.Link == "" {
			continue
		}

		wg.Add(1)
		go func(r OrganicResult) {
			defer wg.Done()

			// Acquire semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			report := h.GenerateReport(ctx, r)

			mu.Lock()
			reports[r.Link] = report
			mu.Unlock()
		}(result)
	}

	wg.Wait()

	successCount := 0
	for _, report := range reports {
		if report.Success {
			successCount++
		}
	}

	log.Printf("[PreCallReportHandler] Report generation complete: %d/%d successful", successCount, len(reports))

	return reports
}

// GenerateReportsForSearchResponse generates reports for all organic results in a search response
func (h *PreCallReportHandler) GenerateReportsForSearchResponse(ctx context.Context, searchResponse *SearchResponse) map[string]*PreCallReport {
	if searchResponse == nil || len(searchResponse.OrganicResults) == 0 {
		return make(map[string]*PreCallReport)
	}
	return h.GenerateReports(ctx, searchResponse.OrganicResults)
}
