package handlers

import (
	"context"
	"fmt"
	"log"
	"os"
	"strings"
	"sync"
	"time"

	"webstar/noturno-leadgen-worker/internal/dto"

	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/model/gemini"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/genai"
)

const (
	// DefaultReportTimeout is the timeout for generating a single pre-call report
	DefaultReportTimeout = 60 * time.Second
	// MaxConcurrentReports limits how many reports we generate in parallel
	MaxConcurrentReports = 3
	// DefaultGeminiModel is the default Gemini model to use
	DefaultGeminiModel = "gemini-2.5-flash"
	// DefaultReportFallbackModel is the fallback model when primary model quota is exceeded
	DefaultReportFallbackModel = "gemini-2.5-pro"
)

// PreCallReport represents the generated pre-call report for a lead
// @Description Pre-call report generated by AI for a search result
type PreCallReport struct {
	// URL of the website this report is for
	URL string `json:"url"`
	// CompanyName extracted from the website
	CompanyName string `json:"company_name"`
	// Industry or business sector
	Industry string `json:"industry"`
	// CompanySummary is a brief description of what the company does
	CompanySummary string `json:"company_summary"`
	// KeyServices lists the main services or products offered
	KeyServices []string `json:"key_services"`
	// TargetAudience describes the company's target customers
	TargetAudience string `json:"target_audience"`
	// PotentialPainPoints identifies challenges the company might face
	PotentialPainPoints []string `json:"potential_pain_points"`
	// TalkingPoints are suggested topics for a sales call
	TalkingPoints []string `json:"talking_points"`
	// CompetitiveAdvantages highlights unique selling points
	CompetitiveAdvantages []string `json:"competitive_advantages"`
	// ContactInfo extracted from the website (if available)
	ContactInfo string `json:"contact_info,omitempty"`
	// RecommendedApproach suggests how to approach this lead
	RecommendedApproach string `json:"recommended_approach"`
	// Success indicates whether the report was generated successfully
	Success bool `json:"success"`
	// Error contains the error message if report generation failed
	Error string `json:"error,omitempty"`
	// GeneratedAt is the timestamp when the report was generated
	GeneratedAt time.Time `json:"generated_at"`
}

// PreCallReportConfig holds configuration for the PreCallReportHandler
type PreCallReportConfig struct {
	// APIKey is the Google API key for Gemini (used with Google AI Studio backend)
	APIKey string
	// Model is the Gemini model to use (default: gemini-2.5-flash)
	Model string
	// FallbackModel is used when primary model quota is exceeded (default: gemini-2.5-pro)
	FallbackModel string
	// Timeout for generating each report
	Timeout time.Duration
	// MaxConcurrent limits parallel report generation
	MaxConcurrent int
	// CustomInstruction allows customizing the agent's behavior
	CustomInstruction string
	// UseVertexAI enables Vertex AI backend instead of Google AI Studio
	// When true, requires GCPProject and GCPLocation (or env vars)
	UseVertexAI bool
	// GCPProject is the Google Cloud project ID (for Vertex AI backend)
	GCPProject string
	// GCPLocation is the Google Cloud location/region (for Vertex AI backend, e.g., "us-central1")
	GCPLocation string
}

// PreCallReportHandler handles generating pre-call reports using Google ADK
type PreCallReportHandler struct {
	config          PreCallReportConfig
	agent           agent.Agent
	runner          *runner.Runner
	sessionService  session.Service
	businessProfile *dto.BusinessProfile // Business profile for personalization
	language        string               // Output language: "pt-BR" or "en"
	location        string               // Location for language detection
	// Fallback resources
	fallbackAgent  agent.Agent
	fallbackRunner *runner.Runner
	clientConfig   *genai.ClientConfig
	// Usage tracking
	usageTracker *UsageTrackerHandler
}

// SetBusinessProfile sets the business profile to use for personalizing reports
func (h *PreCallReportHandler) SetBusinessProfile(profile *dto.BusinessProfile) {
	h.businessProfile = profile
	if profile != nil {
		// Detect language based on profile and location
		h.language = DetectLanguage(profile, h.location)
		log.Printf("[PreCallReportHandler] Business profile set: %s (language: %s)", profile.CompanyName, h.language)
	}
}

// SetLocation sets the location for language detection
func (h *PreCallReportHandler) SetLocation(location string) {
	h.location = location
	// Re-detect language with new location
	h.language = DetectLanguage(h.businessProfile, location)
	log.Printf("[PreCallReportHandler] Location set: %s (language: %s)", location, h.language)
}

// ClearBusinessProfile clears the business profile
func (h *PreCallReportHandler) ClearBusinessProfile() {
	h.businessProfile = nil
	h.language = LangPortuguese // Reset to default
}

// SetUsageTracker sets the usage tracker for recording AI usage metrics
func (h *PreCallReportHandler) SetUsageTracker(tracker *UsageTrackerHandler) {
	h.usageTracker = tracker
}

// NewPreCallReportHandler creates a new PreCallReportHandler instance
func NewPreCallReportHandler(config PreCallReportConfig) (*PreCallReportHandler, error) {
	// Check for Vertex AI configuration from env vars
	if os.Getenv("GOOGLE_GENAI_USE_VERTEXAI") == "true" {
		config.UseVertexAI = true
	}
	if config.GCPProject == "" {
		config.GCPProject = os.Getenv("GOOGLE_CLOUD_PROJECT")
	}
	if config.GCPLocation == "" {
		config.GCPLocation = os.Getenv("GOOGLE_CLOUD_LOCATION")
	}

	// Validate configuration based on backend
	if config.UseVertexAI {
		if config.GCPProject == "" {
			return nil, fmt.Errorf("GCP Project is required for Vertex AI (set GOOGLE_CLOUD_PROJECT env var or provide GCPProject in config)")
		}
		if config.GCPLocation == "" {
			return nil, fmt.Errorf("GCP Location is required for Vertex AI (set GOOGLE_CLOUD_LOCATION env var or provide GCPLocation in config)")
		}
	} else {
		// Google AI Studio backend requires API key
		if config.APIKey == "" {
			config.APIKey = os.Getenv("GOOGLE_API_KEY")
		}
		if config.APIKey == "" {
			return nil, fmt.Errorf("Google API key is required (set GOOGLE_API_KEY env var or provide in config)")
		}
	}

	if config.Model == "" {
		config.Model = DefaultGeminiModel
	}
	if config.FallbackModel == "" {
		config.FallbackModel = DefaultReportFallbackModel
	}
	if config.Timeout == 0 {
		config.Timeout = DefaultReportTimeout
	}
	if config.MaxConcurrent == 0 {
		config.MaxConcurrent = MaxConcurrentReports
	}

	ctx := context.Background()

	// Build client config based on backend
	var clientConfig *genai.ClientConfig
	if config.UseVertexAI {
		log.Printf("[PreCallReportHandler] Initializing with Vertex AI backend (project: %s, location: %s, model: %s)",
			config.GCPProject, config.GCPLocation, config.Model)
		clientConfig = &genai.ClientConfig{
			Project:  config.GCPProject,
			Location: config.GCPLocation,
			Backend:  genai.BackendVertexAI,
		}
	} else {
		log.Printf("[PreCallReportHandler] Initializing with Google AI Studio backend (model: %s)", config.Model)
		clientConfig = &genai.ClientConfig{
			APIKey:  config.APIKey,
			Backend: genai.BackendGeminiAPI,
		}
	}

	// Create Gemini model
	model, err := gemini.NewModel(ctx, config.Model, clientConfig)
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create Gemini model: %v", err)
		return nil, fmt.Errorf("failed to create Gemini model: %w", err)
	}

	// Build instruction for the agent
	instruction := buildAgentInstruction(config.CustomInstruction)

	// Create LLM agent for report generation
	reportAgent, err := llmagent.New(llmagent.Config{
		Name:        "pre_call_report_agent",
		Model:       model,
		Description: "AI agent that generates comprehensive pre-call reports for sales leads based on company website data.",
		Instruction: instruction,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create agent: %v", err)
		return nil, fmt.Errorf("failed to create agent: %w", err)
	}

	// Create session service and runner
	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "pre_call_report_generator",
		Agent:          reportAgent,
		SessionService: sessionService,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create runner: %v", err)
		return nil, fmt.Errorf("failed to create runner: %w", err)
	}

	log.Printf("[PreCallReportHandler] Successfully initialized with model: %s (fallback: %s)", config.Model, config.FallbackModel)

	// Note: model is stored internally by the agent, we don't need to keep a reference
	_ = model

	return &PreCallReportHandler{
		config:         config,
		agent:          reportAgent,
		runner:         r,
		sessionService: sessionService,
		clientConfig:   clientConfig,
	}, nil
}

// initFallbackAgent initializes the fallback agent lazily when needed
func (h *PreCallReportHandler) initFallbackAgent() error {
	if h.fallbackRunner != nil {
		return nil // Already initialized
	}

	log.Printf("[PreCallReportHandler] Initializing fallback model: %s", h.config.FallbackModel)

	ctx := context.Background()

	// Create fallback model
	fallbackModel, err := gemini.NewModel(ctx, h.config.FallbackModel, h.clientConfig)
	if err != nil {
		return fmt.Errorf("failed to create fallback model: %w", err)
	}

	// Build instruction for the agent
	instruction := buildAgentInstruction(h.config.CustomInstruction)

	// Create fallback agent
	h.fallbackAgent, err = llmagent.New(llmagent.Config{
		Name:        "pre_call_report_agent_fallback",
		Model:       fallbackModel,
		Description: "AI agent that generates comprehensive pre-call reports for sales leads based on company website data (fallback).",
		Instruction: instruction,
	})
	if err != nil {
		return fmt.Errorf("failed to create fallback agent: %w", err)
	}

	// Create fallback runner
	h.fallbackRunner, err = runner.New(runner.Config{
		AppName:        "pre_call_report_generator_fallback",
		Agent:          h.fallbackAgent,
		SessionService: h.sessionService,
	})
	if err != nil {
		return fmt.Errorf("failed to create fallback runner: %w", err)
	}

	log.Printf("[PreCallReportHandler] Fallback model initialized successfully: %s", h.config.FallbackModel)
	return nil
}

// isReportQuotaExceededError checks if the error is a quota exceeded (429) error
func isReportQuotaExceededError(err error) bool {
	if err == nil {
		return false
	}
	errStr := err.Error()
	return strings.Contains(errStr, "429") || strings.Contains(errStr, "RESOURCE_EXHAUSTED") || strings.Contains(errStr, "quota")
}

// buildAgentInstruction creates the instruction prompt for the agent (bilingual support)
func buildAgentInstruction(customInstruction string) string {
	// Default Portuguese instruction - will be overridden per-request based on language
	baseInstruction := `You are a multilingual sales intelligence analyst specialized in generating comprehensive pre-call reports for B2B sales teams.

Your task is to analyze company website content or data and generate a detailed pre-call report that helps sales representatives prepare for their outreach.

IMPORTANT: You will receive instructions about which language to use (English or Portuguese) in each request. Follow those instructions precisely.

When analyzing a company, you must extract and provide:

1. **Company Name**: The official business name
2. **Industry/Sector**: The industry or sector the company operates in
3. **Company Summary**: A 2-3 sentence overview of what the company does
4. **Key Services**: List 3-5 main services or products offered
5. **Target Audience**: Who are their main customers
6. **Potential Pain Points**: 3-5 challenges this type of business typically faces that our solutions could address
7. **Talking Points**: 3-5 specific conversation starters based on their business
8. **Competitive Advantages**: What makes this company stand out
9. **Contact Information**: Any contact details found (phone, email, address)
10. **Recommended Approach**: How a sales rep should approach this lead

Format your response as a structured report with clear sections. Be specific and actionable.
If certain information is not available from the provided content, make reasonable inferences based on the company type and industry, but indicate when you are inferring.

Always maintain a professional and helpful tone, focused on enabling effective sales conversations.`

	if customInstruction != "" {
		return baseInstruction + "\n\nAdditional Instructions:\n" + customInstruction
	}
	return baseInstruction
}

// GenerateReport generates a pre-call report for a single organic result
func (h *PreCallReportHandler) GenerateReport(ctx context.Context, result OrganicResult) *PreCallReport {
	startTime := time.Now()
	modelUsed := h.config.Model
	report := &PreCallReport{
		URL:         result.Link,
		GeneratedAt: time.Now(),
	}

	// Check if we have content to analyze
	if result.ScrapedContent == "" && result.Snippet == "" {
		report.Error = "no content available for analysis"
		report.Success = false
		return report
	}

	// Build the prompt with available data
	prompt := h.buildPrompt(result)

	// Create context with timeout
	ctx, cancel := context.WithTimeout(ctx, h.config.Timeout)
	defer cancel()

	// Create user message
	userMessage := &genai.Content{
		Role: "user",
		Parts: []*genai.Part{
			{Text: prompt},
		},
	}

	// Create session for this report
	userID := "system"
	createResp, err := h.sessionService.Create(ctx, &session.CreateRequest{
		AppName: "pre_call_report_generator",
		UserID:  userID,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create session for %s: %v", result.Link, err)
		report.Error = fmt.Sprintf("failed to create session: %v", err)
		report.Success = false
		return report
	}
	sessionID := createResp.Session.ID()
	defer func() {
		// Clean up session after use
		_ = h.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   "pre_call_report_generator",
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	// Run the agent
	var responseText string
	var generationErr error
	runConfig := agent.RunConfig{
		StreamingMode: agent.StreamingModeNone,
	}

	log.Printf("[PreCallReportHandler] Generating report for: %s (session: %s)", result.Link, sessionID)

	// Try with primary model
	for event, err := range h.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		if err != nil {
			generationErr = err
			break
		}

		// Collect response text
		if event.Content != nil {
			for _, part := range event.Content.Parts {
				if part.Text != "" {
					responseText += part.Text
				}
			}
		}
	}

	// If primary model failed with quota error, try fallback
	if generationErr != nil && isReportQuotaExceededError(generationErr) {
		log.Printf("[PreCallReportHandler] Quota exceeded for primary model, trying fallback: %s", h.config.FallbackModel)

		// Initialize fallback agent if needed
		if err := h.initFallbackAgent(); err != nil {
			log.Printf("[PreCallReportHandler] Failed to initialize fallback agent: %v", err)
			report.Error = fmt.Sprintf("generation failed (primary quota exceeded, fallback init failed): %v", err)
			report.Success = false
			return report
		}

		// Create a new session for fallback
		fallbackResp, err := h.sessionService.Create(ctx, &session.CreateRequest{
			AppName: "pre_call_report_generator_fallback",
			UserID:  userID,
		})
		if err != nil {
			log.Printf("[PreCallReportHandler] Failed to create fallback session: %v", err)
			report.Error = fmt.Sprintf("generation failed (fallback session error): %v", err)
			report.Success = false
			return report
		}
		fallbackSessionID := fallbackResp.Session.ID()
		defer func() {
			_ = h.sessionService.Delete(ctx, &session.DeleteRequest{
				AppName:   "pre_call_report_generator_fallback",
				UserID:    userID,
				SessionID: fallbackSessionID,
			})
		}()

		// Reset for fallback attempt
		responseText = ""
		generationErr = nil

		log.Printf("[PreCallReportHandler] Retrying with fallback model for: %s (session: %s)", result.Link, fallbackSessionID)
		modelUsed = h.config.FallbackModel

		for event, err := range h.fallbackRunner.Run(ctx, userID, fallbackSessionID, userMessage, runConfig) {
			if err != nil {
				generationErr = err
				break
			}

			if event.Content != nil {
				for _, part := range event.Content.Parts {
					if part.Text != "" {
						responseText += part.Text
					}
				}
			}
		}
	}

	// Handle final error
	if generationErr != nil {
		log.Printf("[PreCallReportHandler] Error during generation for %s: %v", result.Link, generationErr)
		report.Error = fmt.Sprintf("generation failed: %v", generationErr)
		report.Success = false
		// Track failed generation
		if h.usageTracker != nil {
			errMsg := generationErr.Error()
			h.usageTracker.TrackPreCallReport("system", nil, nil, modelUsed, prompt, "", startTime, false, &errMsg)
		}
		return report
	}

	if responseText == "" {
		report.Error = "empty response from AI"
		report.Success = false
		// Track failed generation (empty response)
		if h.usageTracker != nil {
			errMsg := "empty response from AI"
			h.usageTracker.TrackPreCallReport("system", nil, nil, modelUsed, prompt, "", startTime, false, &errMsg)
		}
		return report
	}

	// Parse the response into structured report
	h.parseResponse(responseText, report)
	report.Success = true

	// Track successful generation
	if h.usageTracker != nil {
		h.usageTracker.TrackPreCallReport("system", nil, nil, modelUsed, prompt, responseText, startTime, true, nil)
	}

	log.Printf("[PreCallReportHandler] Successfully generated report for: %s", result.Link)

	return report
}

// buildPrompt creates the prompt for report generation (bilingual)
func (h *PreCallReportHandler) buildPrompt(result OrganicResult) string {
	// Determine language - default to Portuguese
	lang := h.language
	if lang == "" {
		lang = LangPortuguese
	}

	var prompt string
	if lang == LangEnglish {
		prompt = h.buildEnglishPrompt(result)
	} else {
		prompt = h.buildPortuguesePrompt(result)
	}

	return prompt
}

// buildPortuguesePrompt creates the prompt in Portuguese
func (h *PreCallReportHandler) buildPortuguesePrompt(result OrganicResult) string {
	prompt := fmt.Sprintf(`Gere um relatório pré-call completo e detalhado em PORTUGUÊS para a seguinte empresa:

**Website**: %s
**Nome**: %s
**Descrição**: %s
`, result.Link, result.Title, result.Snippet)

	// Include business profile context for personalization
	if h.businessProfile != nil {
		prompt += "\n---\n**CONTEXTO DA SUA EMPRESA** (Use para personalizar o relatório):\n"
		prompt += fmt.Sprintf("- Sua Empresa: %s\n", h.businessProfile.CompanyName)
		if h.businessProfile.CompanyDescription != "" {
			prompt += fmt.Sprintf("- O Que Você Faz: %s\n", h.businessProfile.CompanyDescription)
		}
		if h.businessProfile.ProblemSolved != "" {
			prompt += fmt.Sprintf("- Problema Que Você Resolve: %s\n", h.businessProfile.ProblemSolved)
		}
		if len(h.businessProfile.Differentials) > 0 {
			prompt += fmt.Sprintf("- Seus Diferenciais: %s\n", joinStrings(h.businessProfile.Differentials, ", "))
		}
		if h.businessProfile.SuccessCase != "" {
			prompt += fmt.Sprintf("- Caso de Sucesso: %s\n", h.businessProfile.SuccessCase)
		}
		if h.businessProfile.CommunicationTone != "" {
			prompt += fmt.Sprintf("- Tom de Comunicação: %s\n", h.businessProfile.CommunicationTone)
		}
		if h.businessProfile.SenderName != "" {
			prompt += fmt.Sprintf("- Nome do Vendedor: %s\n", h.businessProfile.SenderName)
		}
		prompt += "\n**IMPORTANTE**: Adapte os pontos de dor, pontos de conversa e abordagem recomendada especificamente para como SEUS serviços podem ajudar ESTE lead. Seja específico sobre como sua solução atende às necessidades potenciais dele.\n---\n"
	}

	// Include extracted data if available
	if result.ExtractedData != nil && result.ExtractedData.Success {
		prompt += "\n**Dados Extraídos da Empresa**:\n"
		if result.ExtractedData.Company != "" {
			prompt += fmt.Sprintf("- Nome da Empresa: %s\n", result.ExtractedData.Company)
		}
		if result.ExtractedData.Contact != "" {
			contactInfo := result.ExtractedData.Contact
			if result.ExtractedData.ContactRole != "" {
				contactInfo += " (" + result.ExtractedData.ContactRole + ")"
			}
			prompt += fmt.Sprintf("- Contato: %s\n", contactInfo)
		}
		if len(result.ExtractedData.Emails) > 0 {
			prompt += fmt.Sprintf("- E-mails: %s\n", joinStrings(result.ExtractedData.Emails, ", "))
		}
		if len(result.ExtractedData.Phones) > 0 {
			prompt += fmt.Sprintf("- Telefones: %s\n", joinStrings(result.ExtractedData.Phones, ", "))
		}
		if result.ExtractedData.Address != "" {
			prompt += fmt.Sprintf("- Endereço: %s\n", result.ExtractedData.Address)
		}
		if len(result.ExtractedData.SocialMedia) > 0 {
			prompt += "- Redes Sociais:\n"
			for platform, url := range result.ExtractedData.SocialMedia {
				prompt += fmt.Sprintf("  - %s: %s\n", platform, url)
			}
		}
	}

	if result.ScrapedContent != "" {
		content := result.ScrapedContent
		if len(content) > 15000 {
			content = content[:15000] + "\n\n[Conteúdo truncado...]"
		}
		prompt += fmt.Sprintf(`
**Conteúdo do Site / Dados da Empresa**:
%s
`, content)
	}

	if result.Rating > 0 {
		prompt += fmt.Sprintf("\n**Avaliação**: %.1f", result.Rating)
	}
	if result.Reviews > 0 {
		prompt += fmt.Sprintf("\n**Número de Avaliações**: %d", result.Reviews)
	}

	prompt += `

Analise estas informações e gere um relatório pré-call detalhado EM PORTUGUÊS com todas as seções necessárias.
Use os dados extraídos da empresa (se disponíveis) para enriquecer seu relatório com informações de contato precisas.

O relatório deve incluir:
- Resumo da empresa
- Setor/Indústria
- Serviços/Produtos principais
- Público-alvo
- Possíveis pontos de dor
- Pontos de conversa sugeridos
- Vantagens competitivas identificadas
- Abordagem recomendada para a ligação`

	return prompt
}

// buildEnglishPrompt creates the prompt in English
func (h *PreCallReportHandler) buildEnglishPrompt(result OrganicResult) string {
	prompt := fmt.Sprintf(`Generate a comprehensive and detailed pre-call report in ENGLISH for the following company:

**Website**: %s
**Name**: %s
**Description**: %s
`, result.Link, result.Title, result.Snippet)

	// Include business profile context for personalization
	if h.businessProfile != nil {
		prompt += "\n---\n**YOUR COMPANY CONTEXT** (Use to personalize the report):\n"
		prompt += fmt.Sprintf("- Your Company: %s\n", h.businessProfile.CompanyName)
		if h.businessProfile.CompanyDescription != "" {
			prompt += fmt.Sprintf("- What You Do: %s\n", h.businessProfile.CompanyDescription)
		}
		if h.businessProfile.ProblemSolved != "" {
			prompt += fmt.Sprintf("- Problem You Solve: %s\n", h.businessProfile.ProblemSolved)
		}
		if len(h.businessProfile.Differentials) > 0 {
			prompt += fmt.Sprintf("- Your Differentials: %s\n", joinStrings(h.businessProfile.Differentials, ", "))
		}
		if h.businessProfile.SuccessCase != "" {
			prompt += fmt.Sprintf("- Success Case: %s\n", h.businessProfile.SuccessCase)
		}
		if h.businessProfile.CommunicationTone != "" {
			prompt += fmt.Sprintf("- Communication Tone: %s\n", h.businessProfile.CommunicationTone)
		}
		if h.businessProfile.SenderName != "" {
			prompt += fmt.Sprintf("- Sales Rep Name: %s\n", h.businessProfile.SenderName)
		}
		prompt += "\n**IMPORTANT**: Adapt the pain points, talking points, and recommended approach specifically for how YOUR services can help THIS lead. Be specific about how your solution addresses their potential needs.\n---\n"
	}

	// Include extracted data if available
	if result.ExtractedData != nil && result.ExtractedData.Success {
		prompt += "\n**Extracted Company Data**:\n"
		if result.ExtractedData.Company != "" {
			prompt += fmt.Sprintf("- Company Name: %s\n", result.ExtractedData.Company)
		}
		if result.ExtractedData.Contact != "" {
			contactInfo := result.ExtractedData.Contact
			if result.ExtractedData.ContactRole != "" {
				contactInfo += " (" + result.ExtractedData.ContactRole + ")"
			}
			prompt += fmt.Sprintf("- Contact: %s\n", contactInfo)
		}
		if len(result.ExtractedData.Emails) > 0 {
			prompt += fmt.Sprintf("- Emails: %s\n", joinStrings(result.ExtractedData.Emails, ", "))
		}
		if len(result.ExtractedData.Phones) > 0 {
			prompt += fmt.Sprintf("- Phones: %s\n", joinStrings(result.ExtractedData.Phones, ", "))
		}
		if result.ExtractedData.Address != "" {
			prompt += fmt.Sprintf("- Address: %s\n", result.ExtractedData.Address)
		}
		if len(result.ExtractedData.SocialMedia) > 0 {
			prompt += "- Social Media:\n"
			for platform, url := range result.ExtractedData.SocialMedia {
				prompt += fmt.Sprintf("  - %s: %s\n", platform, url)
			}
		}
	}

	if result.ScrapedContent != "" {
		content := result.ScrapedContent
		if len(content) > 15000 {
			content = content[:15000] + "\n\n[Content truncated...]"
		}
		prompt += fmt.Sprintf(`
**Website Content / Company Data**:
%s
`, content)
	}

	if result.Rating > 0 {
		prompt += fmt.Sprintf("\n**Rating**: %.1f", result.Rating)
	}
	if result.Reviews > 0 {
		prompt += fmt.Sprintf("\n**Number of Reviews**: %d", result.Reviews)
	}

	prompt += `

Analyze this information and generate a detailed pre-call report IN ENGLISH with all required sections.
Use the extracted company data (if available) to enrich your report with accurate contact information.

The report should include:
- Company summary
- Industry/Sector
- Main services/products
- Target audience
- Potential pain points
- Suggested talking points
- Identified competitive advantages
- Recommended approach for the call`

	return prompt
}

// joinStrings joins a slice of strings with a separator
func joinStrings(strs []string, sep string) string {
	if len(strs) == 0 {
		return ""
	}
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += sep + strs[i]
	}
	return result
}

// parseResponse extracts structured data from the AI response
func (h *PreCallReportHandler) parseResponse(response string, report *PreCallReport) {
	// The AI response is in markdown format, we store the full response
	// and extract key fields. For now, we'll store the full analysis
	// and let the consumer parse specific fields as needed.

	// Store the full response in CompanySummary for now
	// In a production system, you might use structured output or regex parsing
	report.CompanySummary = response

	// Try to extract company name from the response
	// This is a simplified extraction - in production you might use
	// Gemini's structured output feature
	report.CompanyName = extractSection(response, "Company Name")
	report.Industry = extractSection(response, "Industry")
	report.TargetAudience = extractSection(response, "Target Audience")
	report.ContactInfo = extractSection(response, "Contact Information")
	report.RecommendedApproach = extractSection(response, "Recommended Approach")

	// Extract list sections
	report.KeyServices = extractListSection(response, "Key Services")
	report.PotentialPainPoints = extractListSection(response, "Potential Pain Points")
	report.TalkingPoints = extractListSection(response, "Talking Points")
	report.CompetitiveAdvantages = extractListSection(response, "Competitive Advantages")
}

// extractSection extracts a single-value section from markdown response
func extractSection(response, sectionName string) string {
	// Simple extraction - looks for **Section Name**: value or ## Section Name\nvalue
	// This is a basic implementation; production code might use regex or structured output
	patterns := []string{
		fmt.Sprintf("**%s**:", sectionName),
		fmt.Sprintf("## %s", sectionName),
		fmt.Sprintf("### %s", sectionName),
		fmt.Sprintf("%s:", sectionName),
	}

	for _, pattern := range patterns {
		idx := findCaseInsensitive(response, pattern)
		if idx != -1 {
			start := idx + len(pattern)
			// Find the end of the value (next section or double newline)
			end := len(response)
			for i := start; i < len(response)-1; i++ {
				if (response[i] == '\n' && response[i+1] == '\n') ||
					(response[i] == '\n' && i+1 < len(response) && (response[i+1] == '#' || response[i+1] == '*')) {
					end = i
					break
				}
			}
			value := response[start:end]
			return trimValue(value)
		}
	}
	return ""
}

// extractListSection extracts a list section from markdown response
func extractListSection(response, sectionName string) []string {
	var items []string

	// Find the section
	patterns := []string{
		fmt.Sprintf("**%s**:", sectionName),
		fmt.Sprintf("## %s", sectionName),
		fmt.Sprintf("### %s", sectionName),
		fmt.Sprintf("%s:", sectionName),
	}

	sectionStart := -1
	for _, pattern := range patterns {
		idx := findCaseInsensitive(response, pattern)
		if idx != -1 {
			sectionStart = idx + len(pattern)
			break
		}
	}

	if sectionStart == -1 {
		return items
	}

	// Find section end
	sectionEnd := len(response)
	for i := sectionStart; i < len(response)-1; i++ {
		if response[i] == '\n' && i+1 < len(response) {
			next := response[i+1]
			// Check for next section header
			if next == '#' || (next == '*' && i+2 < len(response) && response[i+2] == '*') {
				// Make sure it's not a list item
				if next == '*' && i+2 < len(response) && response[i+2] != '*' {
					continue // It's a list item, not a header
				}
				sectionEnd = i
				break
			}
		}
	}

	sectionContent := response[sectionStart:sectionEnd]

	// Extract list items (- item or * item or 1. item)
	lines := splitLines(sectionContent)
	for _, line := range lines {
		trimmed := trimValue(line)
		if len(trimmed) > 2 {
			// Check for list markers
			if (trimmed[0] == '-' || trimmed[0] == '*') && trimmed[1] == ' ' {
				items = append(items, trimValue(trimmed[2:]))
			} else if len(trimmed) > 3 && trimmed[0] >= '0' && trimmed[0] <= '9' && trimmed[1] == '.' && trimmed[2] == ' ' {
				items = append(items, trimValue(trimmed[3:]))
			}
		}
	}

	return items
}

// findCaseInsensitive finds a substring case-insensitively
func findCaseInsensitive(s, substr string) int {
	sLower := toLower(s)
	substrLower := toLower(substr)
	for i := 0; i <= len(sLower)-len(substrLower); i++ {
		if sLower[i:i+len(substrLower)] == substrLower {
			return i
		}
	}
	return -1
}

// toLower converts string to lowercase (simple ASCII version)
func toLower(s string) string {
	result := make([]byte, len(s))
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c >= 'A' && c <= 'Z' {
			result[i] = c + 32
		} else {
			result[i] = c
		}
	}
	return string(result)
}

// splitLines splits text into lines
func splitLines(s string) []string {
	var lines []string
	start := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			lines = append(lines, s[start:i])
			start = i + 1
		}
	}
	if start < len(s) {
		lines = append(lines, s[start:])
	}
	return lines
}

// trimValue removes leading/trailing whitespace and common markdown artifacts
func trimValue(s string) string {
	// Remove leading/trailing whitespace
	start := 0
	end := len(s)
	for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') {
		end--
	}
	return s[start:end]
}

// sanitizeURL creates a safe string from URL for use in IDs
func sanitizeURL(url string) string {
	result := make([]byte, 0, len(url))
	for i := 0; i < len(url); i++ {
		c := url[i]
		if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') {
			result = append(result, c)
		} else if c == '.' || c == '-' || c == '_' {
			result = append(result, c)
		}
	}
	if len(result) > 50 {
		result = result[:50]
	}
	return string(result)
}

// GenerateReports generates pre-call reports for multiple organic results concurrently
func (h *PreCallReportHandler) GenerateReports(ctx context.Context, results []OrganicResult) map[string]*PreCallReport {
	if len(results) == 0 {
		return make(map[string]*PreCallReport)
	}

	log.Printf("[PreCallReportHandler] Generating reports for %d results", len(results))

	reports := make(map[string]*PreCallReport)
	var mu sync.Mutex
	var wg sync.WaitGroup

	// Semaphore to limit concurrent report generation
	semaphore := make(chan struct{}, h.config.MaxConcurrent)

	for _, result := range results {
		// Skip results without URLs
		if result.Link == "" {
			continue
		}

		wg.Add(1)
		go func(r OrganicResult) {
			defer wg.Done()

			// Acquire semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			report := h.GenerateReport(ctx, r)

			mu.Lock()
			reports[r.Link] = report
			mu.Unlock()
		}(result)
	}

	wg.Wait()

	successCount := 0
	for _, report := range reports {
		if report.Success {
			successCount++
		}
	}

	log.Printf("[PreCallReportHandler] Report generation complete: %d/%d successful", successCount, len(reports))

	return reports
}

// GenerateReportsForSearchResponse generates reports for all organic results in a search response
func (h *PreCallReportHandler) GenerateReportsForSearchResponse(ctx context.Context, searchResponse *SearchResponse) map[string]*PreCallReport {
	if searchResponse == nil || len(searchResponse.OrganicResults) == 0 {
		return make(map[string]*PreCallReport)
	}
	return h.GenerateReports(ctx, searchResponse.OrganicResults)
}
