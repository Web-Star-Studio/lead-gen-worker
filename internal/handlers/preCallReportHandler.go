package handlers

import (
	"context"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/model/gemini"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/genai"
)

const (
	// DefaultReportTimeout is the timeout for generating a single pre-call report
	DefaultReportTimeout = 60 * time.Second
	// MaxConcurrentReports limits how many reports we generate in parallel
	MaxConcurrentReports = 3
	// DefaultGeminiModel is the default Gemini model to use
	DefaultGeminiModel = "gemini-2.5-pro-preview-06-05"
)

// PreCallReport represents the generated pre-call report for a lead
// @Description Pre-call report generated by AI for a search result
type PreCallReport struct {
	// URL of the website this report is for
	URL string `json:"url"`
	// CompanyName extracted from the website
	CompanyName string `json:"company_name"`
	// Industry or business sector
	Industry string `json:"industry"`
	// CompanySummary is a brief description of what the company does
	CompanySummary string `json:"company_summary"`
	// KeyServices lists the main services or products offered
	KeyServices []string `json:"key_services"`
	// TargetAudience describes the company's target customers
	TargetAudience string `json:"target_audience"`
	// PotentialPainPoints identifies challenges the company might face
	PotentialPainPoints []string `json:"potential_pain_points"`
	// TalkingPoints are suggested topics for a sales call
	TalkingPoints []string `json:"talking_points"`
	// CompetitiveAdvantages highlights unique selling points
	CompetitiveAdvantages []string `json:"competitive_advantages"`
	// ContactInfo extracted from the website (if available)
	ContactInfo string `json:"contact_info,omitempty"`
	// RecommendedApproach suggests how to approach this lead
	RecommendedApproach string `json:"recommended_approach"`
	// Success indicates whether the report was generated successfully
	Success bool `json:"success"`
	// Error contains the error message if report generation failed
	Error string `json:"error,omitempty"`
	// GeneratedAt is the timestamp when the report was generated
	GeneratedAt time.Time `json:"generated_at"`
}

// PreCallReportConfig holds configuration for the PreCallReportHandler
type PreCallReportConfig struct {
	// APIKey is the Google API key for Gemini (used with Google AI Studio backend)
	APIKey string
	// Model is the Gemini model to use (default: gemini-2.5-pro-preview-06-05)
	Model string
	// Timeout for generating each report
	Timeout time.Duration
	// MaxConcurrent limits parallel report generation
	MaxConcurrent int
	// CustomInstruction allows customizing the agent's behavior
	CustomInstruction string
	// UseVertexAI enables Vertex AI backend instead of Google AI Studio
	// When true, requires GCPProject and GCPLocation (or env vars)
	UseVertexAI bool
	// GCPProject is the Google Cloud project ID (for Vertex AI backend)
	GCPProject string
	// GCPLocation is the Google Cloud location/region (for Vertex AI backend, e.g., "us-central1")
	GCPLocation string
}

// PreCallReportHandler handles generating pre-call reports using Google ADK
type PreCallReportHandler struct {
	config         PreCallReportConfig
	agent          agent.Agent
	runner         *runner.Runner
	sessionService session.Service
}

// NewPreCallReportHandler creates a new PreCallReportHandler instance
func NewPreCallReportHandler(config PreCallReportConfig) (*PreCallReportHandler, error) {
	// Check for Vertex AI configuration from env vars
	if os.Getenv("GOOGLE_GENAI_USE_VERTEXAI") == "true" {
		config.UseVertexAI = true
	}
	if config.GCPProject == "" {
		config.GCPProject = os.Getenv("GOOGLE_CLOUD_PROJECT")
	}
	if config.GCPLocation == "" {
		config.GCPLocation = os.Getenv("GOOGLE_CLOUD_LOCATION")
	}

	// Validate configuration based on backend
	if config.UseVertexAI {
		if config.GCPProject == "" {
			return nil, fmt.Errorf("GCP Project is required for Vertex AI (set GOOGLE_CLOUD_PROJECT env var or provide GCPProject in config)")
		}
		if config.GCPLocation == "" {
			return nil, fmt.Errorf("GCP Location is required for Vertex AI (set GOOGLE_CLOUD_LOCATION env var or provide GCPLocation in config)")
		}
	} else {
		// Google AI Studio backend requires API key
		if config.APIKey == "" {
			config.APIKey = os.Getenv("GOOGLE_API_KEY")
		}
		if config.APIKey == "" {
			return nil, fmt.Errorf("Google API key is required (set GOOGLE_API_KEY env var or provide in config)")
		}
	}

	if config.Model == "" {
		config.Model = DefaultGeminiModel
	}
	if config.Timeout == 0 {
		config.Timeout = DefaultReportTimeout
	}
	if config.MaxConcurrent == 0 {
		config.MaxConcurrent = MaxConcurrentReports
	}

	ctx := context.Background()

	// Build client config based on backend
	var clientConfig *genai.ClientConfig
	if config.UseVertexAI {
		log.Printf("[PreCallReportHandler] Initializing with Vertex AI backend (project: %s, location: %s, model: %s)",
			config.GCPProject, config.GCPLocation, config.Model)
		clientConfig = &genai.ClientConfig{
			Project:  config.GCPProject,
			Location: config.GCPLocation,
			Backend:  genai.BackendVertexAI,
		}
	} else {
		log.Printf("[PreCallReportHandler] Initializing with Google AI Studio backend (model: %s)", config.Model)
		clientConfig = &genai.ClientConfig{
			APIKey:  config.APIKey,
			Backend: genai.BackendGeminiAPI,
		}
	}

	// Create Gemini model
	model, err := gemini.NewModel(ctx, config.Model, clientConfig)
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create Gemini model: %v", err)
		return nil, fmt.Errorf("failed to create Gemini model: %w", err)
	}

	// Build instruction for the agent
	instruction := buildAgentInstruction(config.CustomInstruction)

	// Create LLM agent for report generation
	reportAgent, err := llmagent.New(llmagent.Config{
		Name:        "pre_call_report_agent",
		Model:       model,
		Description: "AI agent that generates comprehensive pre-call reports for sales leads based on company website data.",
		Instruction: instruction,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create agent: %v", err)
		return nil, fmt.Errorf("failed to create agent: %w", err)
	}

	// Create session service and runner
	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "pre_call_report_generator",
		Agent:          reportAgent,
		SessionService: sessionService,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create runner: %v", err)
		return nil, fmt.Errorf("failed to create runner: %w", err)
	}

	log.Printf("[PreCallReportHandler] Successfully initialized with model: %s", config.Model)

	// Note: model is stored internally by the agent, we don't need to keep a reference
	_ = model

	return &PreCallReportHandler{
		config:         config,
		agent:          reportAgent,
		runner:         r,
		sessionService: sessionService,
	}, nil
}

// buildAgentInstruction creates the instruction prompt for the agent
func buildAgentInstruction(customInstruction string) string {
	baseInstruction := `You are an expert sales intelligence analyst specializing in generating comprehensive pre-call reports for B2B sales teams.

Your task is to analyze website content and generate a detailed pre-call report that helps sales representatives prepare for their outreach.

When analyzing a company, you must extract and provide:

1. **Company Name**: The official name of the business
2. **Industry**: The sector or industry the company operates in
3. **Company Summary**: A 2-3 sentence overview of what the company does
4. **Key Services**: List 3-5 main services or products offered
5. **Target Audience**: Who are their primary customers
6. **Potential Pain Points**: 3-5 challenges this type of business typically faces that our solutions could address
7. **Talking Points**: 3-5 specific conversation starters based on their business
8. **Competitive Advantages**: What makes this company stand out
9. **Contact Information**: Any contact details found (phone, email, address)
10. **Recommended Approach**: How should a sales rep approach this lead

Format your response as a structured report with clear sections. Be specific and actionable.
If certain information is not available from the provided content, make reasonable inferences based on the company type and industry, but note when you're inferring.

Always maintain a professional, helpful tone focused on enabling effective sales conversations.`

	if customInstruction != "" {
		return baseInstruction + "\n\nAdditional Instructions:\n" + customInstruction
	}
	return baseInstruction
}

// GenerateReport generates a pre-call report for a single organic result
func (h *PreCallReportHandler) GenerateReport(ctx context.Context, result OrganicResult) *PreCallReport {
	report := &PreCallReport{
		URL:         result.Link,
		GeneratedAt: time.Now(),
	}

	// Check if we have content to analyze
	if result.ScrapedContent == "" && result.Snippet == "" {
		report.Error = "no content available for analysis"
		report.Success = false
		return report
	}

	// Build the prompt with available data
	prompt := h.buildPrompt(result)

	// Create context with timeout
	ctx, cancel := context.WithTimeout(ctx, h.config.Timeout)
	defer cancel()

	// Create user message
	userMessage := &genai.Content{
		Role: "user",
		Parts: []*genai.Part{
			{Text: prompt},
		},
	}

	// Create session for this report
	userID := "system"
	createResp, err := h.sessionService.Create(ctx, &session.CreateRequest{
		AppName: "pre_call_report_generator",
		UserID:  userID,
	})
	if err != nil {
		log.Printf("[PreCallReportHandler] Failed to create session for %s: %v", result.Link, err)
		report.Error = fmt.Sprintf("failed to create session: %v", err)
		report.Success = false
		return report
	}
	sessionID := createResp.Session.ID()
	defer func() {
		// Clean up session after use
		_ = h.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   "pre_call_report_generator",
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	// Run the agent
	var responseText string
	runConfig := agent.RunConfig{
		StreamingMode: agent.StreamingModeNone,
	}

	log.Printf("[PreCallReportHandler] Generating report for: %s (session: %s)", result.Link, sessionID)

	for event, err := range h.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		if err != nil {
			log.Printf("[PreCallReportHandler] Error during generation for %s: %v", result.Link, err)
			report.Error = fmt.Sprintf("generation failed: %v", err)
			report.Success = false
			return report
		}

		// Collect response text
		if event.Content != nil {
			for _, part := range event.Content.Parts {
				if part.Text != "" {
					responseText += part.Text
				}
			}
		}
	}

	if responseText == "" {
		report.Error = "empty response from AI"
		report.Success = false
		return report
	}

	// Parse the response into structured report
	h.parseResponse(responseText, report)
	report.Success = true

	log.Printf("[PreCallReportHandler] Successfully generated report for: %s", result.Link)

	return report
}

// buildPrompt creates the prompt for report generation
func (h *PreCallReportHandler) buildPrompt(result OrganicResult) string {
	prompt := fmt.Sprintf(`Generate a comprehensive pre-call report for the following company:

**Website URL**: %s
**Title**: %s
**Search Snippet**: %s
`, result.Link, result.Title, result.Snippet)

	// Include extracted data if available
	if result.ExtractedData != nil && result.ExtractedData.Success {
		prompt += "\n**Extracted Company Data**:\n"
		if result.ExtractedData.Company != "" {
			prompt += fmt.Sprintf("- Company Name: %s\n", result.ExtractedData.Company)
		}
		if result.ExtractedData.Contact != "" {
			contactInfo := result.ExtractedData.Contact
			if result.ExtractedData.ContactRole != "" {
				contactInfo += " (" + result.ExtractedData.ContactRole + ")"
			}
			prompt += fmt.Sprintf("- Contact: %s\n", contactInfo)
		}
		if len(result.ExtractedData.Emails) > 0 {
			prompt += fmt.Sprintf("- Emails: %s\n", joinStrings(result.ExtractedData.Emails, ", "))
		}
		if len(result.ExtractedData.Phones) > 0 {
			prompt += fmt.Sprintf("- Phones: %s\n", joinStrings(result.ExtractedData.Phones, ", "))
		}
		if result.ExtractedData.Address != "" {
			prompt += fmt.Sprintf("- Address: %s\n", result.ExtractedData.Address)
		}
		if len(result.ExtractedData.SocialMedia) > 0 {
			prompt += "- Social Media:\n"
			for platform, url := range result.ExtractedData.SocialMedia {
				prompt += fmt.Sprintf("  - %s: %s\n", platform, url)
			}
		}
	}

	if result.ScrapedContent != "" {
		// Limit content length to avoid token limits
		content := result.ScrapedContent
		if len(content) > 15000 {
			content = content[:15000] + "\n\n[Content truncated...]"
		}
		prompt += fmt.Sprintf(`
**Website Content**:
%s
`, content)
	}

	if result.Rating > 0 {
		prompt += fmt.Sprintf("\n**Rating**: %.1f", result.Rating)
	}
	if result.Reviews > 0 {
		prompt += fmt.Sprintf("\n**Reviews**: %d", result.Reviews)
	}

	prompt += `

Please analyze this information and generate a detailed pre-call report with all the required sections.
Use the extracted company data (if available) to enrich your report with accurate contact information.`

	return prompt
}

// joinStrings joins a slice of strings with a separator
func joinStrings(strs []string, sep string) string {
	if len(strs) == 0 {
		return ""
	}
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += sep + strs[i]
	}
	return result
}

// parseResponse extracts structured data from the AI response
func (h *PreCallReportHandler) parseResponse(response string, report *PreCallReport) {
	// The AI response is in markdown format, we store the full response
	// and extract key fields. For now, we'll store the full analysis
	// and let the consumer parse specific fields as needed.

	// Store the full response in CompanySummary for now
	// In a production system, you might use structured output or regex parsing
	report.CompanySummary = response

	// Try to extract company name from the response
	// This is a simplified extraction - in production you might use
	// Gemini's structured output feature
	report.CompanyName = extractSection(response, "Company Name")
	report.Industry = extractSection(response, "Industry")
	report.TargetAudience = extractSection(response, "Target Audience")
	report.ContactInfo = extractSection(response, "Contact Information")
	report.RecommendedApproach = extractSection(response, "Recommended Approach")

	// Extract list sections
	report.KeyServices = extractListSection(response, "Key Services")
	report.PotentialPainPoints = extractListSection(response, "Potential Pain Points")
	report.TalkingPoints = extractListSection(response, "Talking Points")
	report.CompetitiveAdvantages = extractListSection(response, "Competitive Advantages")
}

// extractSection extracts a single-value section from markdown response
func extractSection(response, sectionName string) string {
	// Simple extraction - looks for **Section Name**: value or ## Section Name\nvalue
	// This is a basic implementation; production code might use regex or structured output
	patterns := []string{
		fmt.Sprintf("**%s**:", sectionName),
		fmt.Sprintf("## %s", sectionName),
		fmt.Sprintf("### %s", sectionName),
		fmt.Sprintf("%s:", sectionName),
	}

	for _, pattern := range patterns {
		idx := findCaseInsensitive(response, pattern)
		if idx != -1 {
			start := idx + len(pattern)
			// Find the end of the value (next section or double newline)
			end := len(response)
			for i := start; i < len(response)-1; i++ {
				if (response[i] == '\n' && response[i+1] == '\n') ||
					(response[i] == '\n' && i+1 < len(response) && (response[i+1] == '#' || response[i+1] == '*')) {
					end = i
					break
				}
			}
			value := response[start:end]
			return trimValue(value)
		}
	}
	return ""
}

// extractListSection extracts a list section from markdown response
func extractListSection(response, sectionName string) []string {
	var items []string

	// Find the section
	patterns := []string{
		fmt.Sprintf("**%s**:", sectionName),
		fmt.Sprintf("## %s", sectionName),
		fmt.Sprintf("### %s", sectionName),
		fmt.Sprintf("%s:", sectionName),
	}

	sectionStart := -1
	for _, pattern := range patterns {
		idx := findCaseInsensitive(response, pattern)
		if idx != -1 {
			sectionStart = idx + len(pattern)
			break
		}
	}

	if sectionStart == -1 {
		return items
	}

	// Find section end
	sectionEnd := len(response)
	for i := sectionStart; i < len(response)-1; i++ {
		if response[i] == '\n' && i+1 < len(response) {
			next := response[i+1]
			// Check for next section header
			if next == '#' || (next == '*' && i+2 < len(response) && response[i+2] == '*') {
				// Make sure it's not a list item
				if next == '*' && i+2 < len(response) && response[i+2] != '*' {
					continue // It's a list item, not a header
				}
				sectionEnd = i
				break
			}
		}
	}

	sectionContent := response[sectionStart:sectionEnd]

	// Extract list items (- item or * item or 1. item)
	lines := splitLines(sectionContent)
	for _, line := range lines {
		trimmed := trimValue(line)
		if len(trimmed) > 2 {
			// Check for list markers
			if (trimmed[0] == '-' || trimmed[0] == '*') && trimmed[1] == ' ' {
				items = append(items, trimValue(trimmed[2:]))
			} else if len(trimmed) > 3 && trimmed[0] >= '0' && trimmed[0] <= '9' && trimmed[1] == '.' && trimmed[2] == ' ' {
				items = append(items, trimValue(trimmed[3:]))
			}
		}
	}

	return items
}

// findCaseInsensitive finds a substring case-insensitively
func findCaseInsensitive(s, substr string) int {
	sLower := toLower(s)
	substrLower := toLower(substr)
	for i := 0; i <= len(sLower)-len(substrLower); i++ {
		if sLower[i:i+len(substrLower)] == substrLower {
			return i
		}
	}
	return -1
}

// toLower converts string to lowercase (simple ASCII version)
func toLower(s string) string {
	result := make([]byte, len(s))
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c >= 'A' && c <= 'Z' {
			result[i] = c + 32
		} else {
			result[i] = c
		}
	}
	return string(result)
}

// splitLines splits text into lines
func splitLines(s string) []string {
	var lines []string
	start := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			lines = append(lines, s[start:i])
			start = i + 1
		}
	}
	if start < len(s) {
		lines = append(lines, s[start:])
	}
	return lines
}

// trimValue removes leading/trailing whitespace and common markdown artifacts
func trimValue(s string) string {
	// Remove leading/trailing whitespace
	start := 0
	end := len(s)
	for start < end && (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') {
		start++
	}
	for end > start && (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') {
		end--
	}
	return s[start:end]
}

// sanitizeURL creates a safe string from URL for use in IDs
func sanitizeURL(url string) string {
	result := make([]byte, 0, len(url))
	for i := 0; i < len(url); i++ {
		c := url[i]
		if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') {
			result = append(result, c)
		} else if c == '.' || c == '-' || c == '_' {
			result = append(result, c)
		}
	}
	if len(result) > 50 {
		result = result[:50]
	}
	return string(result)
}

// GenerateReports generates pre-call reports for multiple organic results concurrently
func (h *PreCallReportHandler) GenerateReports(ctx context.Context, results []OrganicResult) map[string]*PreCallReport {
	if len(results) == 0 {
		return make(map[string]*PreCallReport)
	}

	log.Printf("[PreCallReportHandler] Generating reports for %d results", len(results))

	reports := make(map[string]*PreCallReport)
	var mu sync.Mutex
	var wg sync.WaitGroup

	// Semaphore to limit concurrent report generation
	semaphore := make(chan struct{}, h.config.MaxConcurrent)

	for _, result := range results {
		// Skip results without URLs
		if result.Link == "" {
			continue
		}

		wg.Add(1)
		go func(r OrganicResult) {
			defer wg.Done()

			// Acquire semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			report := h.GenerateReport(ctx, r)

			mu.Lock()
			reports[r.Link] = report
			mu.Unlock()
		}(result)
	}

	wg.Wait()

	successCount := 0
	for _, report := range reports {
		if report.Success {
			successCount++
		}
	}

	log.Printf("[PreCallReportHandler] Report generation complete: %d/%d successful", successCount, len(reports))

	return reports
}

// GenerateReportsForSearchResponse generates reports for all organic results in a search response
func (h *PreCallReportHandler) GenerateReportsForSearchResponse(ctx context.Context, searchResponse *SearchResponse) map[string]*PreCallReport {
	if searchResponse == nil || len(searchResponse.OrganicResults) == 0 {
		return make(map[string]*PreCallReport)
	}
	return h.GenerateReports(ctx, searchResponse.OrganicResults)
}
