package handlers

import (
	"context"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"webstar/noturno-leadgen-worker/internal/dto"

	"google.golang.org/adk/agent"
	"google.golang.org/adk/agent/llmagent"
	"google.golang.org/adk/model/gemini"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/genai"
)

const (
	// DefaultEmailTimeout is the timeout for generating a single cold email
	DefaultEmailTimeout = 45 * time.Second
	// MaxConcurrentEmails limits how many emails we generate in parallel
	MaxConcurrentEmails = 3
	// DefaultEmailModel is the default Gemini model to use for email generation
	DefaultEmailModel = "gemini-2.5-flash"
)

// ColdEmail represents the generated cold email for a lead
// @Description Cold email generated by AI for first contact with a lead
type ColdEmail struct {
	// LeadID is the ID of the lead this email is for
	LeadID string `json:"lead_id,omitempty"`
	// URL of the website this email is for
	URL string `json:"url"`
	// RecipientName is the name of the person receiving the email
	RecipientName string `json:"recipient_name"`
	// RecipientCompany is the company of the recipient
	RecipientCompany string `json:"recipient_company"`
	// Subject is the email subject line
	Subject string `json:"subject"`
	// Body is the main email content (HTML or plain text)
	Body string `json:"body"`
	// PlainTextBody is the plain text version of the email
	PlainTextBody string `json:"plain_text_body"`
	// CallToAction is the specific action requested from the recipient
	CallToAction string `json:"call_to_action"`
	// PersonalizationNotes explains how the email was personalized
	PersonalizationNotes string `json:"personalization_notes,omitempty"`
	// Success indicates whether the email was generated successfully
	Success bool `json:"success"`
	// Error contains the error message if email generation failed
	Error string `json:"error,omitempty"`
	// GeneratedAt is the timestamp when the email was generated
	GeneratedAt time.Time `json:"generated_at"`
}

// ColdEmailConfig holds configuration for the ColdEmailHandler
type ColdEmailConfig struct {
	// APIKey is the Google API key for Gemini (used with Google AI Studio backend)
	APIKey string
	// Model is the Gemini model to use (default: gemini-2.5-flash for speed)
	Model string
	// Timeout for generating each email
	Timeout time.Duration
	// MaxConcurrent limits parallel email generation
	MaxConcurrent int
	// CustomInstruction allows customizing the agent's behavior
	CustomInstruction string
	// UseVertexAI enables Vertex AI backend instead of Google AI Studio
	UseVertexAI bool
	// GCPProject is the Google Cloud project ID (for Vertex AI backend)
	GCPProject string
	// GCPLocation is the Google Cloud location/region (for Vertex AI backend)
	GCPLocation string
}

// ColdEmailHandler handles generating cold emails using Google ADK
type ColdEmailHandler struct {
	config          ColdEmailConfig
	agent           agent.Agent
	runner          *runner.Runner
	sessionService  session.Service
	businessProfile *dto.BusinessProfile // Business profile for personalization
	language        string               // Output language: "pt-BR" or "en"
	location        string               // Location for language detection
}

// SetBusinessProfile sets the business profile to use for personalizing emails
func (h *ColdEmailHandler) SetBusinessProfile(profile *dto.BusinessProfile) {
	h.businessProfile = profile
	if profile != nil {
		// Detect language based on profile and location
		h.language = DetectLanguage(profile, h.location)
		log.Printf("[ColdEmailHandler] Business profile set: %s (language: %s)", profile.CompanyName, h.language)
	}
}

// SetLocation sets the location for language detection
func (h *ColdEmailHandler) SetLocation(location string) {
	h.location = location
	// Re-detect language with new location
	h.language = DetectLanguage(h.businessProfile, location)
	log.Printf("[ColdEmailHandler] Location set: %s (language: %s)", location, h.language)
}

// ClearBusinessProfile clears the business profile
func (h *ColdEmailHandler) ClearBusinessProfile() {
	h.businessProfile = nil
	h.language = LangPortuguese // Reset to default
}

// NewColdEmailHandler creates a new ColdEmailHandler instance
func NewColdEmailHandler(config ColdEmailConfig) (*ColdEmailHandler, error) {
	// Check for Vertex AI configuration from env vars
	if os.Getenv("GOOGLE_GENAI_USE_VERTEXAI") == "true" {
		config.UseVertexAI = true
	}
	if config.GCPProject == "" {
		config.GCPProject = os.Getenv("GOOGLE_CLOUD_PROJECT")
	}
	if config.GCPLocation == "" {
		config.GCPLocation = os.Getenv("GOOGLE_CLOUD_LOCATION")
	}

	// Validate configuration based on backend
	if config.UseVertexAI {
		if config.GCPProject == "" {
			return nil, fmt.Errorf("GCP Project is required for Vertex AI (set GOOGLE_CLOUD_PROJECT env var or provide GCPProject in config)")
		}
		if config.GCPLocation == "" {
			return nil, fmt.Errorf("GCP Location is required for Vertex AI (set GOOGLE_CLOUD_LOCATION env var or provide GCPLocation in config)")
		}
	} else {
		// Google AI Studio backend requires API key
		if config.APIKey == "" {
			config.APIKey = os.Getenv("GOOGLE_API_KEY")
		}
		if config.APIKey == "" {
			return nil, fmt.Errorf("Google API key is required (set GOOGLE_API_KEY env var or provide in config)")
		}
	}

	if config.Model == "" {
		config.Model = DefaultEmailModel
	}
	if config.Timeout == 0 {
		config.Timeout = DefaultEmailTimeout
	}
	if config.MaxConcurrent == 0 {
		config.MaxConcurrent = MaxConcurrentEmails
	}

	ctx := context.Background()

	// Build client config based on backend
	var clientConfig *genai.ClientConfig
	if config.UseVertexAI {
		log.Printf("[ColdEmailHandler] Initializing with Vertex AI backend (project: %s, location: %s, model: %s)",
			config.GCPProject, config.GCPLocation, config.Model)
		clientConfig = &genai.ClientConfig{
			Project:  config.GCPProject,
			Location: config.GCPLocation,
			Backend:  genai.BackendVertexAI,
		}
	} else {
		log.Printf("[ColdEmailHandler] Initializing with Google AI Studio backend (model: %s)", config.Model)
		clientConfig = &genai.ClientConfig{
			APIKey:  config.APIKey,
			Backend: genai.BackendGeminiAPI,
		}
	}

	// Create Gemini model
	model, err := gemini.NewModel(ctx, config.Model, clientConfig)
	if err != nil {
		log.Printf("[ColdEmailHandler] Failed to create Gemini model: %v", err)
		return nil, fmt.Errorf("failed to create Gemini model: %w", err)
	}

	// Build instruction for the agent
	instruction := buildEmailAgentInstruction(config.CustomInstruction)

	// Create LLM agent for email generation
	emailAgent, err := llmagent.New(llmagent.Config{
		Name:        "cold_email_agent",
		Model:       model,
		Description: "AI agent that generates personalized B2B cold emails for first contact with sales leads.",
		Instruction: instruction,
	})
	if err != nil {
		log.Printf("[ColdEmailHandler] Failed to create agent: %v", err)
		return nil, fmt.Errorf("failed to create agent: %w", err)
	}

	// Create session service and runner
	sessionService := session.InMemoryService()
	r, err := runner.New(runner.Config{
		AppName:        "cold_email_generator",
		Agent:          emailAgent,
		SessionService: sessionService,
	})
	if err != nil {
		log.Printf("[ColdEmailHandler] Failed to create runner: %v", err)
		return nil, fmt.Errorf("failed to create runner: %w", err)
	}

	log.Printf("[ColdEmailHandler] Successfully initialized with model: %s", config.Model)

	return &ColdEmailHandler{
		config:         config,
		agent:          emailAgent,
		runner:         r,
		sessionService: sessionService,
	}, nil
}

// buildEmailAgentInstruction creates the instruction prompt for the cold email agent
func buildEmailAgentInstruction(customInstruction string) string {
	// Bilingual instruction - actual language is specified per-request in the prompt
	baseInstruction := `You are a B2B copywriting and sales expert, specialized in creating highly personalized and effective first-contact cold emails.

IMPORTANT: You will receive instructions about which language to use (English or Portuguese) in each request. Follow those instructions precisely.

Your goal is to create emails that:
1. Are short and direct (maximum 150 words in the body)
2. Demonstrate specific knowledge about the prospect's company
3. Present clear and relevant value to the prospect
4. Have a clear, low-commitment CTA (call-to-action)
5. Avoid generic or spam-like language

EMAIL STRUCTURE:

**SUBJECT** (maximum 50 characters):
- Personalized with company name or specific insight
- Generate curiosity without being clickbait
- Avoid words that trigger spam filters (free, urgent, offer)

**EMAIL BODY**:
1. **Personalized opening** (1-2 sentences): Mention something specific about the company (service, achievement, industry challenge)
2. **Value connection** (2-3 sentences): Connect their problem/opportunity with your solution
3. **Quick social proof** (1 sentence, optional): Mention a result or similar client
4. **Low-commitment CTA** (1 sentence): Invite for a quick conversation, not a direct sale

IMPORTANT RULES:
- Use professional but human tone (not robotic)
- Personalize with specific prospect data (name, company, sector), but don't use placeholders like "[name]" or "[company]" or "[sector]"
- Never use overly formal greetings - use first name
- DO NOT include signature, closing salutation, or footer (e.g., "Best regards", "[Your Name]", company name). The signature will be automatically added by the sending system.
- Don't use excessive emojis
- Avoid attachments or suspicious links in the first message

RESPONSE FORMAT:
Respond EXACTLY in this format:

SUBJECT: [subject line here]

---

BODY:
[email body here]

---

CTA: [description of the call-to-action used]

---

PERSONALIZATION NOTES: [briefly explain how you personalized the email]`

	if customInstruction != "" {
		return baseInstruction + "\n\nAdditional Instructions:\n" + customInstruction
	}
	return baseInstruction
}

// EmailGenerationInput contains all data needed to generate a cold email
type EmailGenerationInput struct {
	// OrganicResult contains the search result data
	Result OrganicResult
	// PreCallReport contains the AI-generated analysis (if available)
	PreCallReport string
	// RecipientEmail is the target email address
	RecipientEmail string
}

// GenerateEmail generates a cold email for a single lead
func (h *ColdEmailHandler) GenerateEmail(ctx context.Context, input EmailGenerationInput) *ColdEmail {
	email := &ColdEmail{
		URL:         input.Result.Link,
		GeneratedAt: time.Now(),
	}

	// Check if we have enough data to generate an email
	if input.Result.ExtractedData == nil && input.Result.Snippet == "" && input.PreCallReport == "" {
		email.Error = "insufficient data for email generation"
		email.Success = false
		return email
	}

	// Set recipient info from extracted data
	if input.Result.ExtractedData != nil {
		email.RecipientName = input.Result.ExtractedData.Contact
		email.RecipientCompany = input.Result.ExtractedData.Company
	}
	if email.RecipientCompany == "" {
		email.RecipientCompany = input.Result.Title
	}

	// Build the prompt with available data
	prompt := h.buildEmailPrompt(input)

	// Create context with timeout
	ctx, cancel := context.WithTimeout(ctx, h.config.Timeout)
	defer cancel()

	// Create user message
	userMessage := &genai.Content{
		Role: "user",
		Parts: []*genai.Part{
			{Text: prompt},
		},
	}

	// Create session for this email
	userID := "system"
	createResp, err := h.sessionService.Create(ctx, &session.CreateRequest{
		AppName: "cold_email_generator",
		UserID:  userID,
	})
	if err != nil {
		log.Printf("[ColdEmailHandler] Failed to create session for %s: %v", input.Result.Link, err)
		email.Error = fmt.Sprintf("failed to create session: %v", err)
		email.Success = false
		return email
	}
	sessionID := createResp.Session.ID()
	defer func() {
		// Clean up session after use
		_ = h.sessionService.Delete(ctx, &session.DeleteRequest{
			AppName:   "cold_email_generator",
			UserID:    userID,
			SessionID: sessionID,
		})
	}()

	// Run the agent
	var responseText string
	runConfig := agent.RunConfig{
		StreamingMode: agent.StreamingModeNone,
	}

	log.Printf("[ColdEmailHandler] Generating email for: %s (session: %s)", input.Result.Link, sessionID)

	for event, err := range h.runner.Run(ctx, userID, sessionID, userMessage, runConfig) {
		if err != nil {
			log.Printf("[ColdEmailHandler] Error during generation for %s: %v", input.Result.Link, err)
			email.Error = fmt.Sprintf("generation failed: %v", err)
			email.Success = false
			return email
		}

		// Collect response text
		if event.Content != nil {
			for _, part := range event.Content.Parts {
				if part.Text != "" {
					responseText += part.Text
				}
			}
		}
	}

	if responseText == "" {
		email.Error = "empty response from AI"
		email.Success = false
		return email
	}

	// Parse the response into structured email
	h.parseEmailResponse(responseText, email)
	email.Success = true

	log.Printf("[ColdEmailHandler] Successfully generated email for: %s", input.Result.Link)

	return email
}

// buildEmailPrompt creates the prompt for email generation (bilingual)
func (h *ColdEmailHandler) buildEmailPrompt(input EmailGenerationInput) string {
	// Determine language - default to Portuguese
	lang := h.language
	if lang == "" {
		lang = LangPortuguese
	}

	if lang == LangEnglish {
		return h.buildEnglishEmailPrompt(input)
	}
	return h.buildPortugueseEmailPrompt(input)
}

// buildPortugueseEmailPrompt creates the email prompt in Portuguese
func (h *ColdEmailHandler) buildPortugueseEmailPrompt(input EmailGenerationInput) string {
	prompt := "Gere um cold email de primeiro contato EM PORTUGUÊS para o seguinte prospect:\n\n"

	// Add prospect information
	prompt += "**DADOS DO PROSPECT**:\n"
	prompt += fmt.Sprintf("- Website: %s\n", input.Result.Link)
	prompt += fmt.Sprintf("- Título: %s\n", input.Result.Title)

	if input.Result.Snippet != "" {
		prompt += fmt.Sprintf("- Descrição: %s\n", input.Result.Snippet)
	}

	// Add extracted data if available
	if input.Result.ExtractedData != nil && input.Result.ExtractedData.Success {
		if input.Result.ExtractedData.Company != "" {
			prompt += fmt.Sprintf("- Empresa: %s\n", input.Result.ExtractedData.Company)
		}
		if input.Result.ExtractedData.Contact != "" {
			contactInfo := input.Result.ExtractedData.Contact
			if input.Result.ExtractedData.ContactRole != "" {
				contactInfo += " (" + input.Result.ExtractedData.ContactRole + ")"
			}
			prompt += fmt.Sprintf("- Contato: %s\n", contactInfo)
		}
		if len(input.Result.ExtractedData.Emails) > 0 {
			prompt += fmt.Sprintf("- Email: %s\n", input.Result.ExtractedData.Emails[0])
		}
	}

	// Add pre-call report analysis if available
	if input.PreCallReport != "" {
		prompt += "\n**ANÁLISE PRÉ-CALL (use para personalização)**:\n"
		report := input.PreCallReport
		if len(report) > 5000 {
			report = report[:5000] + "\n[Análise truncada...]"
		}
		prompt += report + "\n"
	}

	// Add business profile (sender's company) for context
	if h.businessProfile != nil {
		prompt += "\n**SUA EMPRESA (remetente)**:\n"
		prompt += fmt.Sprintf("- Nome: %s\n", h.businessProfile.CompanyName)
		if h.businessProfile.CompanyDescription != "" {
			prompt += fmt.Sprintf("- O que fazemos: %s\n", h.businessProfile.CompanyDescription)
		}
		if h.businessProfile.ProblemSolved != "" {
			prompt += fmt.Sprintf("- Problema que resolvemos: %s\n", h.businessProfile.ProblemSolved)
		}
		if len(h.businessProfile.Differentials) > 0 {
			prompt += fmt.Sprintf("- Diferenciais: %s\n", joinStrings(h.businessProfile.Differentials, ", "))
		}
		if h.businessProfile.SuccessCase != "" {
			prompt += fmt.Sprintf("- Caso de sucesso: %s\n", h.businessProfile.SuccessCase)
		}
		if h.businessProfile.CommunicationTone != "" {
			prompt += fmt.Sprintf("- Tom de comunicação: %s\n", h.businessProfile.CommunicationTone)
		}
		if h.businessProfile.SenderName != "" {
			prompt += fmt.Sprintf("- Assinatura: %s\n", h.businessProfile.SenderName)
		}
	}

	prompt += "\n**IMPORTANTE**: Crie um email altamente personalizado EM PORTUGUÊS usando os dados acima. O email deve parecer que foi escrito especificamente para este prospect, não um template genérico."
	prompt += "\n\nUse o formato: ASSUNTO: ... / CORPO: ... / CTA: ... / NOTAS DE PERSONALIZAÇÃO: ..."

	return prompt
}

// buildEnglishEmailPrompt creates the email prompt in English
func (h *ColdEmailHandler) buildEnglishEmailPrompt(input EmailGenerationInput) string {
	prompt := "Generate a first-contact cold email IN ENGLISH for the following prospect:\n\n"

	// Add prospect information
	prompt += "**PROSPECT DATA**:\n"
	prompt += fmt.Sprintf("- Website: %s\n", input.Result.Link)
	prompt += fmt.Sprintf("- Title: %s\n", input.Result.Title)

	if input.Result.Snippet != "" {
		prompt += fmt.Sprintf("- Description: %s\n", input.Result.Snippet)
	}

	// Add extracted data if available
	if input.Result.ExtractedData != nil && input.Result.ExtractedData.Success {
		if input.Result.ExtractedData.Company != "" {
			prompt += fmt.Sprintf("- Company: %s\n", input.Result.ExtractedData.Company)
		}
		if input.Result.ExtractedData.Contact != "" {
			contactInfo := input.Result.ExtractedData.Contact
			if input.Result.ExtractedData.ContactRole != "" {
				contactInfo += " (" + input.Result.ExtractedData.ContactRole + ")"
			}
			prompt += fmt.Sprintf("- Contact: %s\n", contactInfo)
		}
		if len(input.Result.ExtractedData.Emails) > 0 {
			prompt += fmt.Sprintf("- Email: %s\n", input.Result.ExtractedData.Emails[0])
		}
	}

	// Add pre-call report analysis if available
	if input.PreCallReport != "" {
		prompt += "\n**PRE-CALL ANALYSIS (use for personalization)**:\n"
		report := input.PreCallReport
		if len(report) > 5000 {
			report = report[:5000] + "\n[Analysis truncated...]"
		}
		prompt += report + "\n"
	}

	// Add business profile (sender's company) for context
	if h.businessProfile != nil {
		prompt += "\n**YOUR COMPANY (sender)**:\n"
		prompt += fmt.Sprintf("- Name: %s\n", h.businessProfile.CompanyName)
		if h.businessProfile.CompanyDescription != "" {
			prompt += fmt.Sprintf("- What we do: %s\n", h.businessProfile.CompanyDescription)
		}
		if h.businessProfile.ProblemSolved != "" {
			prompt += fmt.Sprintf("- Problem we solve: %s\n", h.businessProfile.ProblemSolved)
		}
		if len(h.businessProfile.Differentials) > 0 {
			prompt += fmt.Sprintf("- Differentials: %s\n", joinStrings(h.businessProfile.Differentials, ", "))
		}
		if h.businessProfile.SuccessCase != "" {
			prompt += fmt.Sprintf("- Success case: %s\n", h.businessProfile.SuccessCase)
		}
		if h.businessProfile.CommunicationTone != "" {
			prompt += fmt.Sprintf("- Communication tone: %s\n", h.businessProfile.CommunicationTone)
		}
		if h.businessProfile.SenderName != "" {
			prompt += fmt.Sprintf("- Signature: %s\n", h.businessProfile.SenderName)
		}
	}

	prompt += "\n**IMPORTANT**: Create a highly personalized email IN ENGLISH using the data above. The email should look like it was written specifically for this prospect, not a generic template."
	prompt += "\n\nUse the format: SUBJECT: ... / BODY: ... / CTA: ... / PERSONALIZATION NOTES: ..."

	return prompt
}

// parseEmailResponse extracts structured data from the AI response (supports both English and Portuguese)
func (h *ColdEmailHandler) parseEmailResponse(response string, email *ColdEmail) {
	// Extract subject (try both Portuguese and English)
	email.Subject = extractEmailSection(response, "ASSUNTO")
	if email.Subject == "" {
		email.Subject = extractEmailSection(response, "SUBJECT")
	}

	// Extract body (try both Portuguese and English)
	email.Body = extractEmailSection(response, "CORPO")
	if email.Body == "" {
		email.Body = extractEmailSection(response, "BODY")
	}
	email.PlainTextBody = email.Body // For now, same as body

	// Extract CTA (same in both languages)
	email.CallToAction = extractEmailSection(response, "CTA")

	// Extract personalization notes (try both Portuguese and English)
	email.PersonalizationNotes = extractEmailSection(response, "NOTAS DE PERSONALIZAÇÃO")
	if email.PersonalizationNotes == "" {
		email.PersonalizationNotes = extractEmailSection(response, "PERSONALIZATION NOTES")
	}

	// If parsing failed, store raw response in body
	if email.Subject == "" && email.Body == "" {
		email.Body = response
		email.PlainTextBody = response
	}
}

// extractEmailSection extracts a section from the AI response
func extractEmailSection(response, sectionName string) string {
	// Look for section markers
	patterns := []string{
		sectionName + ":",
		sectionName + " :",
		"**" + sectionName + "**:",
		"**" + sectionName + "**",
	}

	for _, pattern := range patterns {
		idx := findCaseInsensitive(response, pattern)
		if idx != -1 {
			start := idx + len(pattern)
			// Skip any leading whitespace or newlines
			for start < len(response) && (response[start] == ' ' || response[start] == '\n' || response[start] == '\r') {
				start++
			}

			// Find the end (next section marker or ---)
			end := len(response)
			// Look for --- separator
			sepIdx := -1
			for i := start; i < len(response)-2; i++ {
				if response[i] == '-' && response[i+1] == '-' && response[i+2] == '-' {
					sepIdx = i
					break
				}
			}
			if sepIdx != -1 {
				end = sepIdx
			}

			value := response[start:end]
			return trimValue(value)
		}
	}
	return ""
}

// GenerateEmails generates cold emails for multiple leads concurrently
func (h *ColdEmailHandler) GenerateEmails(ctx context.Context, inputs []EmailGenerationInput) map[string]*ColdEmail {
	if len(inputs) == 0 {
		return make(map[string]*ColdEmail)
	}

	log.Printf("[ColdEmailHandler] Generating emails for %d leads", len(inputs))

	emails := make(map[string]*ColdEmail)
	var mu sync.Mutex
	var wg sync.WaitGroup

	// Semaphore to limit concurrent email generation
	semaphore := make(chan struct{}, h.config.MaxConcurrent)

	for _, input := range inputs {
		// Skip inputs without URLs
		if input.Result.Link == "" {
			continue
		}

		wg.Add(1)
		go func(inp EmailGenerationInput) {
			defer wg.Done()

			// Acquire semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			email := h.GenerateEmail(ctx, inp)

			mu.Lock()
			emails[inp.Result.Link] = email
			mu.Unlock()
		}(input)
	}

	wg.Wait()

	successCount := 0
	for _, email := range emails {
		if email.Success {
			successCount++
		}
	}

	log.Printf("[ColdEmailHandler] Email generation complete: %d/%d successful", successCount, len(emails))

	return emails
}
